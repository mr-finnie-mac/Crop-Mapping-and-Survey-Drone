import time
import open3d as o3d
import numpy as np
import matplotlib.pyplot as plt
import cv2 as cv
import os
import sys
from config import *
# import main

# # monkey patches visualization and provides helpers to load geometries
# sys.path.append('Open3D-master/examples/python/')
# import open3d_tutorial as o3dtut
# # change to True if you want to interact with the visualization windows
# o3dtut.interactive = not "CI" in os.environ

# # Load in color and depth image to create the point cloud
# color_raw = o3d.io.read_image("./img_sets/square_dataset/images/1677066757881_L.jpeg")
# # color_raw = cv.bitwise_not(color_raw) # depth and image data currently inverse to eachother, need to correct on one source. (depth)
# depth_raw = o3d.io.read_image("./archived_data/depth_map_1678632358672.png")
# rgbd_image = o3d.geometry.RGBDImage.create_from_color_and_depth(
#     color_raw, depth_raw)
# print(rgbd_image)



# # Plot the images
# plt.subplot(1, 2, 1)
# plt.title('Grayscale image')
# plt.imshow(rgbd_image.color)
# plt.subplot(1, 2, 2)
# plt.title('Depth image')
# plt.imshow(rgbd_image.depth)
# plt.show()



# # # Camera intrinsic parameters built into Open3D for Prime Sense
# # camera_intrinsic = o3d.camera.PinholeCameraIntrinsic(
# #         o3d.camera.PinholeCameraIntrinsicParameters.PrimeSenseDefault)


# # load in intrinsic camera parameters from file generated by calibration script
# cv_file = cv.FileStorage()
# cv_file.open('cameraIntrinsic.xml', cv.FileStorage_READ)
# # locate intrinsic params
# camera_intrinsic = cv_file.getNode('intrinsic').mat()
# print(camera_intrinsic)

# # Obtain intrinsic camera parameters from file and convert it something o3d understands (pinholeCameraIntrinsic object)
# camera_intrinsic_o3d = o3d.camera.PinholeCameraIntrinsic(width=1920, height=1080, fx=camera_intrinsic[0][0],fy=camera_intrinsic[1][1], cx=camera_intrinsic[0][2], cy=camera_intrinsic[1][2])
# print(camera_intrinsic_o3d.intrinsic_matrix)

# # Create the point cloud from images and camera intrisic parameters
# pcd = o3d.geometry.PointCloud.create_from_rgbd_image(rgbd_image, intrinsic=camera_intrinsic_o3d)
    
# # Flip it, otherwise the pointcloud will be upside down
# # pcd.transform([[1, 0, 0, 0], [0, -1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]])
# # o3d.visualization.draw_geometries([pcd])#, zoom=0.5)
# pcd.scale(-1.0, center = pcd.get_center())

# o3d.io.write_point_cloud("exported_model.ply", pcd, False, False, False)

# vis = o3d.visualization.Visualizer()
# vis.create_window("Pointcloud - Square_dataset")


# # condition pointcloud for voxelgrid
# N = 2000
# pcd.scale(1 / np.max(pcd.get_max_bound() - pcd.get_min_bound()), center=pcd.get_center())
# # pcd.colors = o3d.utility.Vector3dVector(np.random.uniform(0, 1, size=(N, 3)))
# print('Displaying input point cloud ...')
# o3d.visualization.draw_geometries([pcd])

# vis.create_window("Pointcloud - Square_dataset")
# # pointcloud to voxel grid
# print('Displaying voxel grid ...')
# voxel_grid = o3d.geometry.VoxelGrid.create_from_point_cloud(pcd, voxel_size=0.0025)
# o3d.visualization.draw_geometries([voxel_grid])

# construct pointcloud from depthmap and image
def make_rgbd(image_path, depth_path):
    """Make rgb depth image from colour image and depth image. Returns rgbd object"""
    # Load in color and depth image to create the point cloud
    color_raw = o3d.io.read_image(image_path)
    # color_raw = cv.bitwise_not(color_raw) # depth and image data currently inverse to eachother, need to correct on one source. (depth)
    depth_raw = o3d.io.read_image(depth_path)
    rgbd_image = o3d.geometry.RGBDImage.create_from_color_and_depth(
        color_raw, depth_raw)
    print("Made RGBD:")
    print(rgbd_image)
    return rgbd_image

def convert_to_ply(rgbd_image):
    "Constructs a ply pointcloud from rgbd image"
    # load in intrinsic camera parameters from file generated by calibration script
    cv_file = cv.FileStorage()
    cv_file.open(CURRENT_INTRINSICS, cv.FileStorage_READ)
    # locate intrinsic params
    camera_intrinsic = cv_file.getNode('intrinsic').mat()
    print(camera_intrinsic)

    # Obtain intrinsic camera parameters from file and convert it something o3d understands (pinholeCameraIntrinsic object)
    camera_intrinsic_o3d = o3d.camera.PinholeCameraIntrinsic(width=1920, height=1080, fx=camera_intrinsic[0][0],fy=camera_intrinsic[1][1], cx=camera_intrinsic[0][2], cy=camera_intrinsic[1][2])
    print(camera_intrinsic_o3d.intrinsic_matrix)

    # Create the point cloud from images and camera intrisic parameters
    pcd = o3d.geometry.PointCloud.create_from_rgbd_image(rgbd_image, intrinsic=camera_intrinsic_o3d)
    pcd.scale(-1.0, center = pcd.get_center()) # inverting the scale so points are not wrong way round

    return pcd

def condition_pointcloud(pcd):
    pcd.scale(-1.0, center = pcd.get_center())
    pcd.scale(1 / np.max(pcd.get_max_bound() - pcd.get_min_bound()), center=pcd.get_center())
    # pcd.colors = o3d.utility.Vector3dVector(np.random.uniform(0, 1, size=(2000, 3))) # enable for blue-red depth colour shift
    return pcd

def observe_pointcloud(pcd):
    # vis = o3d.visualization.Visualizer()
    # vis.create_window("Pointcloud")
    pcd.scale(-1.0, center = pcd.get_center())
    print('Opening point cloud in window')
    o3d.visualization.draw_geometries([pcd])

def convert_ply_to_voxel(pcd):
    # vis = o3d.visualization.Visualizer()
    # vis.create_window("Pointcloud - Square_dataset")
    # pointcloud to voxel grid
    print('Displaying voxel grid ...')
    voxel_grid = o3d.geometry.VoxelGrid.create_from_point_cloud(pcd, voxel_size=0.005)
    o3d.visualization.draw_geometries([voxel_grid])
    return voxel_grid

def export_pointcloud(pcd, filename=str(round(time.time()*1000))+"_exported_model.ply"):
    o3d.io.write_point_cloud('%s%s'%(PLY_DESTINATION_PATH, filename), pcd, False, False, False)
    print("Pointcloud exported to " + PLY_DESTINATION_PATH)

def downsample_pointcloud(pcd):
    """Downsamples the provided pointcloud. Returns a downsampled pointcloud"""
    # downsample our pcd
    ds_voxel = pcd.uniform_down_sample(every_k_points=K_POINTS)
    return ds_voxel

def radial_outlier_inlier(ds_pcd, remove=False):
    "Performs outlier removal within a radius using a downsampled pointcloud. Returns cloud and index values"
    cl, ind = ds_pcd.remove_radius_outlier(nb_points=16, radius=0.005)

    return (cl, ind) if remove==False else (ds_pcd.select_by_index(ind)) # return either cloud and index or cloud with removed outlier values

def display_inlier_outlier(cloud, ind):
    """Displays inlier - outlier using pointcloud and index values"""
    inlier_cloud = cloud.select_by_index(ind)
    outlier_cloud = cloud.select_by_index(ind, invert=True)

    print("Showing outliers (red) and inliers (gray): ")
    outlier_cloud.paint_uniform_color([1, 0, 0])
    inlier_cloud.paint_uniform_color([0.8, 0.8, 0.8])
    o3d.visualization.draw_geometries([inlier_cloud, outlier_cloud])




