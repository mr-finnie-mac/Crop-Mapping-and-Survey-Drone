import glob
import time
import open3d as o3d
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import colors as plt_colors
import cv2 as cv
import os
import sys
from config import *
import copy
from sous import *
import random

# Create a custom colormap with 100 colors
custom_cmap = ['#8B4513', '#3F3F3F', '#7F7F7F', '#BFBFBF', '#FFFFFF', '#FF0000', '#FFA500', '#FFFF00', '#008000', '#0000FF',
          '#4B0082', '#9400D3', '#FF00FF', '#00FFFF', '#ADD8E6', '#F08080', '#90EE90', '#D3D3D3', '#FFC0CB', '#00FF00',
          '#800000', '#FFD700', '#FFA07A', '#7CFC00', '#DC143C', '#00BFFF', '#FF1493', '#FF8C00', '#48D1CC', '#B0C4DE',
          '#00CED1', '#9400D3', '#FF00FF', '#800080', '#FFC0CB', '#00FF00', '#F0E68C', '#ADFF2F', '#6A5ACD', '#FFE4C4',
          '#B8860B', '#FA8072', '#87CEFA', '#BA55D3', '#AFEEEE', '#FFDAB9', '#DA70D6', '#FF7F50', '#00FA9A', '#D8BFD8',
          '#4169E1', '#C71585', '#FF4500', '#FF69B4', '#ADFF2F', '#CD5C5C', '#EEE8AA', '#8A2BE2', '#556B2F', '#FFA07A',
          '#F5DEB3', '#00FFFF', '#00CED1', '#6B8E23', '#DB7093', '#191970', '#FAEBD7', '#FFB6C1', '#00FA9A', '#8B0000',
          '#008B8B', '#F08080', '#FF6347', '#008000', '#000080', '#FF8C00', '#9932CC', '#FF69B4', '#8B008B', '#FFA500',
          '#0000CD', '#800080', '#FFD700', '#98FB98', '#9400D3', '#20B2AA', '#FFE4E1', '#2E8B57', '#FF00FF', '#FF1493',
          '#FFC0CB', '#4169E1', '#B22222', '#FF4500', '#87CEEB', '#228B22', '#8B4513', '#FA8072', '#4B0082', '#ADD8E6',
          '#DAA520', '#1E90FF', '#FF69B4', '#9370DB', '#CD853F', '#FFB6C1', '#FAFAD2', '#90EE90', '#808000', '#BA55D3',
          '#8B0000', '#008080', '#F5DEB3', '#EEE8AA', '#FF7F50', '#00BFFF', '#483D8B', '#FF7F50', '#00BFFF', '#483D8B',
          '#4169E1', '#C71585', '#FF4500', '#FF69B4', '#ADFF2F', '#CD5C5C', '#EEE8AA', '#8A2BE2', '#556B2F', '#FFA07A',
          '#F5DEB3', '#00FFFF', '#00CED1', '#6B8E23', '#DB7093', '#191970', '#FAEBD7', '#FFB6C1', '#00FA9A', '#8B0000',
          '#008B8B', '#F08080', '#FF6347', '#008000', '#000080', '#FF8C00', '#9932CC', '#FF69B4', '#8B008B', '#FFA500',
          '#0000CD', '#800080', '#FFD700', '#98FB98', '#9400D3', '#20B2AA', '#FFE4E1', '#2E8B57', '#FF00FF', '#FF1493',
          '#FFC0CB', '#4169E1', '#B22222', '#FF4500', '#87CEEB', '#228B22', '#8B4513', '#FA8072', '#4B0082', '#ADD8E6',
          '#DAA520', '#1E90FF', '#FF69B4', '#9370DB', '#CD853F', '#FFB6C1', '#FAFAD2', '#90EE90', '#808000', '#BA55D3',
          '#8B0000', '#008080', '#F5DEB3', '#EEE8AA']
rgb_colors = [plt_colors.to_rgb(hex_color) for hex_color in custom_cmap]

# construct pointcloud from depthmap and image path
def make_rgbd(image_path, depth_path):
    """Make rgb depth image from colour image and depth image path in directory. Returns rgbd object"""
    # Load in color and depth image to create the point cloud
    color_raw = o3d.io.read_image(image_path)
    # color_raw = cv.bitwise_not(color_raw) # depth and image data currently inverse to eachother, need to correct on one source. (depth)
    depth_raw = o3d.io.read_image(depth_path)
    plot_images(color_raw, depth_raw)
    rgbd_image = o3d.geometry.RGBDImage.create_from_color_and_depth(
        color_raw, depth_raw)
    print("Made RGBD:")
    print(rgbd_image)
    return rgbd_image

# construct pointcloud from depthmap and image
def make_rgbd_from_np(colourImage, depthImage):
    """Make rgb depth image from colour image and depth image (np array). Returns rgbd object"""
    # Convert ndarray color image and depth images to O3D rgbd
    o3d_colour = o3d.geometry.Image((colourImage).astype(np.uint8))
    o3d_depth = o3d.geometry.Image((depthImage).astype(np.uint8))

    # plot_images(o3d_colour, o3d_depth)
    rgbd_image = o3d.geometry.RGBDImage.create_from_color_and_depth(o3d_colour, o3d_depth)

    return rgbd_image

def plot_rgbd_image_images(rgbd_image):
    """Plots the colour and depth image of an rgbd image."""
    # Plot the images
    plt.subplot(1, 2, 1)
    plt.title('Grayscale image')
    plt.imshow(rgbd_image.color)
    plt.subplot(1, 2, 2)
    plt.title('Depth image')
    plt.imshow(rgbd_image.depth)
    plt.show()

def plot_images(image1, image2):
    plt.subplot(1, 2, 1)
    plt.title('A')
    plt.imshow(image1)
    plt.subplot(1, 2, 2)
    plt.title('B')
    plt.imshow(image2)
    plt.show()

def convert_to_ply(rgbd_image):
    "Constructs a ply pointcloud from rgbd image, returns pcd"
    # load in intrinsic camera parameters from file generated by calibration script
    cv_file = cv.FileStorage()
    cv_file.open(CAMERA_INTRINSICS, cv.FileStorage_READ)
    # locate intrinsic params
    camera_intrinsic = cv_file.getNode('mx').mat()
    print(camera_intrinsic)

    # Obtain intrinsic camera parameters from file and convert it something o3d understands (pinholeCameraIntrinsic object)
    camera_intrinsic_o3d = o3d.camera.PinholeCameraIntrinsic(width=1920, height=1080, fx=camera_intrinsic[0][0],fy=camera_intrinsic[1][1], cx=camera_intrinsic[0][2], cy=camera_intrinsic[1][2])
    # print(camera_intrinsic_o3d.intrinsic_matrix)

    # load in intrinsic camera parameters from file generated by calibration script
    cv_file.open(CAMERA_EXTRINSICS, cv.FileStorage_READ)
    # locate extrinsic params
    camera_extrinsic = np.asarray(cv_file.getNode('mx').mat())
    print(camera_extrinsic)

    # Create the point cloud from images and camera intrisic parameters
    pcd = o3d.geometry.PointCloud.create_from_rgbd_image(rgbd_image, intrinsic=camera_intrinsic_o3d, extrinsic=camera_extrinsic)
    pcd.scale(-1.0, center = pcd.get_center()) # inverting the scale so points are not wrong way round

    return pcd

def condition_pointcloud(pcd, use_depth_colourshift = True):
    """Returns given pointcloud with scale and colour fixed"""
    pcd.scale(-1.0, center = pcd.get_center())
    pcd.scale(1 / np.max(pcd.get_max_bound() - pcd.get_min_bound()), center=pcd.get_center())
    if use_depth_colourshift:
        pcd.colors = o3d.utility.Vector3dVector(np.random.uniform(0, 1, size=(2000, 3))) # enable for blue-red depth colour shift
    return pcd

def observe_pointcloud(pcd):
    """View a pointcloud in open3d visualiser"""
    # vis = o3d.visualization.Visualizer()
    # vis.create_window("Pointcloud")
    pcd.scale(-1.0, center = pcd.get_center())
    print('Opening point cloud in window')
    o3d.visualization.draw_geometries([pcd])

def convert_ply_to_voxel(pcd):
    # vis = o3d.visualization.Visualizer()
    # vis.create_window("Pointcloud - Square_dataset")
    # pointcloud to voxel grid
    print('Displaying voxel grid ...')
    voxel_grid = o3d.geometry.VoxelGrid.create_from_point_cloud(pcd, voxel_size=0.005)
    o3d.visualization.draw_geometries([voxel_grid])
    return voxel_grid

def export_pointcloud(pcd, filename=str(round(time.time()*1000))+"_exported_pcd.ply"):
    o3d.io.write_point_cloud('%s%s'%(PLY_DESTINATION_PATH, filename), pcd, False, False, False)
    print("Pointcloud exported to " + PLY_DESTINATION_PATH)

def downsample_pointcloud(pcd):
    """Downsamples the provided pointcloud. Returns a downsampled pointcloud"""
    # downsample our pcd
    ds_voxel = pcd.uniform_down_sample(every_k_points=K_POINTS)
    return ds_voxel

def radial_outlier_inlier(ds_pcd, remove=False):
    "Performs outlier removal within a radius using a downsampled pointcloud. Returns cloud and index values"
    cl, ind = ds_pcd.remove_radius_outlier(nb_points=16, radius=0.005)

    return (cl, ind) if remove==False else (ds_pcd.select_by_index(ind)) # return either cloud and index or cloud with removed outlier values

def cluster_statistical_outlier_removal(pcd, remove=False, show_process=False):
    "Performs outlier removal within a radius using a downsampled pointcloud. Returns cloud and index values"
    cl, ind = pcd.remove_statistical_outlier(nb_neighbors=DBSCAN_MIN_POINTS-1, std_ratio=2.0)
    if show_process: display_inlier_outlier(pcd, ind)
    return (cl, ind) if remove==False else (pcd.select_by_index(ind)) # return either cloud and index or cloud with removed outlier values

def display_inlier_outlier(cloud, ind):
    """Displays inlier - outlier using pointcloud and index values"""
    inlier_cloud = cloud.select_by_index(ind)
    outlier_cloud = cloud.select_by_index(ind, invert=True)

    print("Showing outliers (red) and inliers (gray): ")
    outlier_cloud.paint_uniform_color([1, 0, 0])
    inlier_cloud.paint_uniform_color([0.8, 0.8, 0.8])
    o3d.visualization.draw_geometries([inlier_cloud, outlier_cloud])

def draw_registration_result(source, target, transformation):
    """Shows how two pointclouds would be combined, provided ICP has been performed and transformation matrix supplied"""
    source_temp = copy.deepcopy(source)
    target_temp = copy.deepcopy(target)
    source_temp.paint_uniform_color([1, 0.706, 0])
    target_temp.paint_uniform_color([0, 0.651, 0.929])
    source_temp.transform(transformation)
    o3d.visualization.draw_geometries([source_temp, target_temp],
                                      zoom=0.4459,
                                      front=[0.9288, -0.2951, -0.2242],
                                      lookat=[1.6784, 2.0612, 1.4451],
                                      up=[-0.3402, -0.9189, -0.1996])

def evaluate_ICP(source, target, threshold=DEFAULT_ICP_THRESHOLD, trans_init=np.asarray([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]])):
    """
        Returns the quality of the ICP, Fitness describes how well they fit (higher is better), or the overlaping areas. 
        More technically, num of inlier correspondences or points in target. RMSD (Root-mean-square deviation)
        describes a measure of error or differnece in value (between points in the two clouds in this case).
    """
    print("Initial alignment")
    evaluation = o3d.pipelines.registration.evaluate_registration(source, target, threshold, trans_init)
    print(evaluation)

def point_to_point_ICP(source, target, threshold=DEFAULT_ICP_THRESHOLD, trans_init=np.asarray([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]])):
    print("Apply point-to-point ICP")
    # reg_p2p = o3d.pipelines.registration.registration_icp(source, target, threshold, trans_init, o3d.pipelines.registration.TransformationEstimationPointToPoint())
    reg_p2p = o3d.pipelines.registration.registration_icp(source, target, threshold, trans_init, o3d.pipelines.registration.TransformationEstimationPointToPoint())
    print(reg_p2p)
    print("Transformation is:")
    print(reg_p2p.transformation)
    draw_registration_result(source, target, reg_p2p.transformation)
    return reg_p2p

def pointcloud_clustering_basic(input_pcd):
    """Implements the DBSCAN clustering method to get segmentation of a pointcloud. Displays these clusters in a multcolour visual"""
    pcd = input_pcd

    with o3d.utility.VerbosityContextManager(
            o3d.utility.VerbosityLevel.Debug) as cm:
        labels = np.array(
            pcd.cluster_dbscan(eps=DBSCAN_EPS, min_points=DBSCAN_MIN_POINTS, print_progress=True))
    max_label = labels.max()
    print(f"point cloud has {max_label + 1} clusters")
    # colors = plt.get_cmap("tab20")(labels / (max_label if max_label > 0 else 1))
    colors = plt_colors.ListedColormap(custom_cmap)(labels / (max_label if max_label > 0 else 1))
    colors[labels < 0] = 0
    pcd.colors = o3d.utility.Vector3dVector(colors[:, :3])
    o3d.visualization.draw_geometries([pcd])

def visualise_segmented_pointcloud_list(pcd_list):
    """Observe a segmented pointcloud in a clustered colours"""

    # generate 200 colours
    # num_colors = 200
    # cmap = plt.get_cmap('tab20')
    # colors_rgb = cmap(np.linspace(0, 1, num_colors))
    # colors_rgb = colors_rgb[:, :3] # convert from rgba to rgb

    num_clusters = len(pcd_list)
    print(num_clusters)
    print(len(rgb_colors))
    # colors = plt_colors.ListedColormap(custom_cmap)#(labels / (max_label if max_label > 0 else 1))
    for i in range(num_clusters):
        # print(rgb_colors[i])
        pcd_list[i].paint_uniform_color(rgb_colors[i])

    o3d.visualization.draw_geometries(pcd_list)
    


def pointcloud_clustering_segmentation(input_pcd):
    """Implements the DBSCAN clustering method to get segmentation of a pointcloud and split the pointcloud up into those clusters. Returns pcd list"""
    pcd = input_pcd

    with o3d.utility.VerbosityContextManager(
            o3d.utility.VerbosityLevel.Debug) as cm:
        labels = np.array(
            pcd.cluster_dbscan(eps=DBSCAN_EPS, min_points=DBSCAN_MIN_POINTS, print_progress=True))

    # Create a list of segmented point clouds
    pcd_list = []
    for i in np.unique(labels):
        points = np.asarray(pcd.points)[labels == i]
        pcd_cluster = o3d.geometry.PointCloud()
        pcd_cluster.points = o3d.utility.Vector3dVector(points)
        pcd_list.append(pcd_cluster)
    
    return pcd_list


    # with o3d.utility.VerbosityContextManager(
    #         o3d.utility.VerbosityLevel.Debug) as cm:
    #     labels = np.array(
    #         pcd.cluster_dbscan(eps=0.02, min_points=10, print_progress=True))

    # max_label = labels.max()
    # print(f"point cloud has {max_label + 1} clusters")
    # # colors = plt.get_cmap("tab20")(labels / (max_label if max_label > 0 else 1))
    # colors = plt_colors.ListedColormap(custom_cmap)(labels / (max_label if max_label > 0 else 1))
    # colors[labels < 0] = 0
    # pcd.colors = o3d.utility.Vector3dVector(colors[:, :3])
    # o3d.visualization.draw_geometries([pcd])

# def combine_via_icp(source, target):
#     convert_to_ply
#     combined = point_to_point_ICP(source=source, target=target)

def generate_rgbd_pack_from_mission(missionCode, path=IMAGE_DESTINATION, image_list = None, depth_list = None):
    """Generate a list of rgbd objects from given mission/directory in the format [[name, rgbd], [name, rgbd]...]"""

    rgbd_list = []
    # if list of image and depth not given,run procedure from folder instead.
    if image_list == None and depth_list == None:
        # find mission code folder then get image and depth folders
        images = glob.glob("%smissions/%s/image/%s"%(path, missionCode, '*.jpeg'), recursive = False)
        depthmaps = glob.glob("%smissions/%s/depth/%s"%(path, missionCode, '*.png'), recursive = False)

        # go through all images in folder and make depthmaps and images for them, save to respective folders
        for image,depth in zip(images, depthmaps):
            # save left frame as image
            imageName_ext = os.path.basename(image)
            depthName_ext = os.path.basename(depth)
            # print(filename_ext)
            currentImage = cv.imread(image)
            currentDepth = cv.imread(depth)
        
        # make rgbd from current image and depth files, then add to list with name attached
            print("Generating rgbd of %s"%(depthName_ext))
            rgbd = make_rgbd_from_np(colourImage=currentImage, depthImage=currentDepth)
            rgbd_list.append([depthName_ext.replace('.png', ''),rgbd])

    else:
        
        for image, depth in zip(image_list, depth_list):
            rgbd = make_rgbd_from_np(colourImage=image, depthImage=depth)
            rgbd_list.append(['', rgbd])


    return rgbd_list

def generate_pointclouds_from_rgbd_list(rgbd_list, use_voxel=True):
    """Generates a pack of pointclouds from a rgbd_list, saves them to path and returns this pack as list of pointclouds (already downsampled!)."""
    pcd_list = []
    for rgbd in rgbd_list:
        print('Converting rgbd %s to pointcloud'%(rgbd[0]))
        pcd = convert_to_ply(rgbd_image=rgbd[1])
        pcd = condition_pointcloud(pcd)
        ds_pcd = downsample_pointcloud(pcd)
        if use_voxel:
            pcd = convert_ply_to_voxel(pcd=ds_pcd)
        else:
            pcd = ds_pcd
        pcd_list.append(pcd)

    return pcd_list

# disparity, filteredDisparity = stereo_depthmap_compute(leftImage=leftRGB, rightImage=rightRGB)
# rgbd = make_rgbd_from_np(leftRGB, filteredDisparity)

# pcd = convert_to_ply(rgbd)
# pcd = condition_pointcloud(pcd)
# refined_pcd = downsample_pointcloud(pcd)
# refined_pcd = radial_outlier_inlier(refined_pcd, remove=True)

# observe_pointcloud(refined_pcd)
# export_pointcloud(refined_pcd)


def analyse_cluster(pcd):
    # volume measure
    axis_bounds = pcd.get_axis_aligned_bounding_box() # measures volume from the ground up, like it's footprint.
    rot_bounds = pcd.get_oriented_bounding_box() # measures volume of the plant
    axis_bounds.color = (0, 1, 0)
    rot_bounds.color = (0, 0, 1)
    print("Volume = ")
    print(axis_bounds.volume())
    print(rot_bounds.volume())
    # o3d.visualization.draw_geometries([pcd, axis_bounds, rot_bounds])

    # posiitonal measure
    center = pcd.get_center()
    dims = rot_bounds.get_box_points()
    # dim_points = rot_bounds.get_box_points()
    # dim_points = o3d.geometry.PointCloud(
    # points=o3d.utility.Vector3dVector(np.asarray(dim_points)))

    return axis_bounds.volume(), rot_bounds.volume(), center, dims

    # """Processes the pointcloud performing conditioning, downsampling, clustering and segmentation"""
    # # raw pointcloud is conditioned and downsampled
    # refined_pcd = condition_pointcloud(pcd)
    # refined_pcd = downsample_pointcloud(refined_pcd)
    # observe_pointcloud(refined_pcd)

    # # pointcloud clusteres are calculated by perfroming DBSCAN algorithm 
    # pcd_clusters = pointcloud_clustering_segmentation(refined_pcd)
    
    # # remove outliers from 
    # refined_pcd_clusters = []
    # for cluster in pcd_clusters:
    #     refined_cluster = cluster#cluster_statistical_outlier_removal(cluster, remove=True, show_process=False)
    #     rand_rgb = random.choice(rgb_colors)
    #     refined_cluster.paint_uniform_color(rand_rgb)
    #     refined_pcd_clusters.append(refined_cluster)
    
    # print('Opening refined pointcloud clusters in window')
    # o3d.visualization.draw_geometries(refined_pcd_clusters)



def process_pointcloud(raw_pcd):
    """Processes the pointcloud performing conditioning, downsampling, clustering and segmentation"""
    # raw pointcloud is conditioned and downsampled
    refined_pcd = condition_pointcloud(raw_pcd)
    refined_pcd = downsample_pointcloud(refined_pcd)
    observe_pointcloud(refined_pcd)

    # pointcloud clusteres are calculated by perfroming DBSCAN algorithm 
    pcd_clusters = pointcloud_clustering_segmentation(refined_pcd)
    clusters_ax_vol = []
    clusters_rot_vol = []
    clusters_center = []
    calculated_dims = []
    # remove outliers from 
    refined_pcd_clusters = []
    for cluster in pcd_clusters:
        refined_cluster = cluster#cluster_statistical_outlier_removal(cluster, remove=True, show_process=False)
        rand_rgb = random.choice(rgb_colors)
        refined_cluster.paint_uniform_color(rand_rgb)
        refined_pcd_clusters.append(refined_cluster)
        ax_vol, rot_vol, center, dims = analyse_cluster(refined_cluster)
        clusters_ax_vol.append(ax_vol)
        clusters_rot_vol.append(rot_vol)
        clusters_center.append(center)
        print(np.asarray(dims))
        calculated_dims.append(dims)
        # calculated_dims

    clusters_ax_vol = np.asarray(clusters_ax_vol)
    clusters_rot_vol = np.asarray(clusters_rot_vol)
    clusters_center = np.asarray(clusters_center)
    ax_vol_mean = np.mean(clusters_ax_vol)
    rot_vol_mean = np.mean(clusters_rot_vol)
    center_mean = np.mean(clusters_center)
    
    print("This map has an average axial volume of %f, rotated volume of %f and the avarage relative position is %f"%(ax_vol_mean, rot_vol_mean, center_mean))

    


        
    
    print('Opening refined pointcloud clusters in window')
    o3d.visualization.draw_geometries(refined_pcd_clusters)

def open_ply(path):
    """Opens the pointcloud at the file path"""
    pcd = o3d.io.read_point_cloud(path)
    return pcd

def process_mission(missionCode):
    "Main loop for reconstruction of 3d scenes from rgbd data"

    # Check folder structure
    # should have been made using camera module's make_new_capture_folder function
    missionPath, imagePath, depthPath = check_mission_folder(missionCode)

    # Making fragments
    # do rgbd making here from imagePath and depthPath 
    rgbd_list = generate_rgbd_pack_from_mission(missionCode=missionCode)

    print(rgbd_list[0][0])

    # Registering fragments


    # Refine registered fragments


    # integrate scene







